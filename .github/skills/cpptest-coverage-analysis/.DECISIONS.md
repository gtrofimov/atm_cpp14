## Design Decisions for cpptest-coverage-analysis

### Decision 1: Tool Choice (cpptest-ct)

**Context**: Multiple C++ coverage tools available (gcov, lcov, cpptest-ct, etc.)

**Choice**: cpptest-ct  
**Rationale**: 
- Excellent coverage instrumentation support
- Native integration with build system (CMake)
- Professional-grade reporting
- Team has existing license and expertise

**Alternative**: gcov/lcov → rejected (requires more manual setup)

### Decision 2: Coverage Instrumentation Level

**Context**: Can instrument at statement/branch/path level

**Choice**: Statement-level coverage (default)  
**Rationale**: Balances comprehensiveness with build speed  
**Reversible**: Can change to branch in CMakeLists.txt

### Decision 3: JSON Output Wrapper (Phase 1)

**Context**: Downstream tools/CI needs structured execution metadata

**Choice**: Separate run-coverage-phase1.sh wrapper  
**Rationale**: 
- Backwards compatible (original script unchanged)
- Easy to test new format
- Can become default when validated
- Enables audit trail with execution ID

**Alternative**: Modify original script → rejected (breaks existing workflows)

### Decision 4: HTML Report Format

**Context**: Coverage report delivery method

**Choice**: HTML with interactive coverage visualization  
**Rationale**: Human-readable, shareable, no special tools needed  
**View**: Open .coverage/index.html in browser
