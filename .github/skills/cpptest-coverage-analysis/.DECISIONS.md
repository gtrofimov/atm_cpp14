## Design Decisions for cpptest-coverage-analysis

### Decision 1: Tool Choice (cpptest-ct)

**Context**: Multiple C++ coverage tools available (gcov, lcov, cpptest-ct, etc.)

**Choice**: cpptest-ct  
**Rationale**: 
- Excellent coverage instrumentation support
- Native integration with build system (CMake)
- Professional-grade reporting
- Team has existing license and expertise

**Alternative**: gcov/lcov → rejected (requires more manual setup)

### Decision 2: Coverage Instrumentation Level

**Context**: Can instrument at statement/branch/path level

**Choice**: Statement-level coverage (default)  
**Rationale**: Balances comprehensiveness with build speed  
**Reversible**: Can change to branch in CMakeLists.txt

### Decision 3: JSON Output in Main Script

**Context**: Downstream tools/CI needs structured execution metadata

**Choice**: Add optional JSON output to run-coverage.sh  
**Rationale**: 
- Single entrypoint for humans and automation
- Keeps backward compatibility (JSON off by default)
- Supports audit trail with execution ID

**Alternative**: Separate wrapper → rejected (duplicate maintenance)

### Decision 4: HTML Report Format

**Context**: Coverage report delivery method

**Choice**: HTML with interactive coverage visualization  
**Rationale**: Human-readable, shareable, no special tools needed  
**View**: Open .coverage/index.html in browser
